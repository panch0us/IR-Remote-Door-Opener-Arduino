// ПОДКЛЮЧЕНИЕ БИБЛИОТЕК
// Библиотека для декодирования ИК-сигналов от пульта
#include <IRremote.h>
// Библиотека для управления сервоприводом
#include <Servo.h>

// ОПРЕДЕЛЕНИЕ КОНСТАНТ (пины и параметры)
// Пин, к которому подключен выход (OUT) ИК-приемника
#define IR_RECEIVE_PIN 11
// Пин, к которому подключен сигнальный провод (SIG) сервопривода
#define SERVO_PIN 9

// ПАРАМЕТРЫ СЕРВОПРИВОДА
// Угол, при котором серва не нажимает на кнопку (НАСТРОЙТЕ!)
#define ANGLE_REST 10
// Угол, при котором серва нажимает на кнопку (НАСТРОЙТЕ!)
#define ANGLE_PRESS 60
// Время (в миллисекундах), сколько серва удерживает нажатие
#define PRESS_DURATION 500
// Пауза (в миллисекундах) после возврата в исходное положение
#define RETURN_DELAY 200

// НАСТРОЙКИ ФИЛЬТРАЦИИ ПОМЕХ
// Переменная для хранения времени последней выполненной команды
unsigned long lastCommandTime = 0;
// Время (в мс) после команды, в течение которой новые команды игнорируются
#define COOLDOWN_PERIOD 300

// Коды, которые будут игнорироваться (мусор и коды повтора)
#define IGNORED_CODE_1 0x0 // Частый код помех
#define IGNORED_CODE_2 0xFFFFFFFF // Код, который отправляется при удержании кнопки

// СОЗДАНИЕ ОБЪЕКТОВ ДЛЯ УПРАВЛЕНИЯ УСТРОЙСТВАМИ
// Объект для управления сервоприводом
Servo myServo;

// ФУНКЦИЯ НАСТРОЙКИ (выполняется один раз при включении)
void setup() {
  // ОТКЛЮЧАЕМ СВЕТОДИОД НА ПИНЕ 13
  pinMode(LED_BUILTIN, OUTPUT);   // Объявляем пин 13 как выход
  digitalWrite(LED_BUILTIN, LOW); // Устанавливаем на нем LOW (0V), чтобы гарантированно погасить его
  
  // Инициализация последовательного порта для отладки через монитор
  Serial.begin(9600);
  // Вывод сообщения о начале работы
  Serial.println("Инициализация системы...");

  // НАСТРОЙКА ИК-ПРИЕМНИКА
  // Запуск ИК-приемника на указанном пине
  IrReceiver.begin(IR_RECEIVE_PIN);
  
  // НАСТРОЙКА СЕРВОПРИВОДА
  // Подключение сервопривода к указанному пину
  myServo.attach(SERVO_PIN);
  // Установка сервы в исходное положение
  myServo.write(ANGLE_REST);
  // Даем время физически переместиться в позицию
  delay(1000);
  // ОТКЛЮЧАЕМ управление сервой после инициализации
  // Это убирает ШИМ-сигнал с пина и предотвращает дрожание
  myServo.detach();
  
  // Сообщение о готовности системы
  Serial.println("Система готова. Ожидание команд...");
}

// ГЛАВНЫЙ ЦИКЛ ПРОГРАММЫ (выполняется постоянно)
void loop() {
  // Проверяем: 1) пришел ли ИК-сигнал, 2) прошел ли период "охлаждения"
  /*
  millis() возвращает количество миллисекунд (тысячных долей секунды), которые прошли с момента включения или перезагрузки Arduino.
  millis() — узнаем текущее "время" (сколько мс прошло с старта).
  lastCommandTime — переменная, в которой мы записали "время" последней выполненной команды.
  millis() - lastCommandTime — вычисляем, сколько миллисекунд прошло с момента последней команды.
  > COOLDOWN_PERIOD — проверяем, прошло ли уже больше 300 мс (значение COOLDOWN_PERIOD).
  */
  if (IrReceiver.decode() && (millis() - lastCommandTime > COOLDOWN_PERIOD)) {
    // Если условия выполнены, получаем значение декодированной команды
    unsigned long receivedCode = IrReceiver.decodedIRData.decodedRawData;
    
    // ФИЛЬТР: проверяем, что это не мусор и не код повтора
    if (receivedCode != IGNORED_CODE_1 && receivedCode != IGNORED_CODE_2) {
      // Если команда прошла фильтр, выводим информацию о ней
      Serial.print("Принята корректная команда: 0x");
      Serial.print(receivedCode, HEX);
      Serial.println(" -> Выполняю действие");

      // Записываем время выполнения этой команды
      lastCommandTime = millis();
      // Вызываем функцию, которая управляет сервоприводом
      pressAndReturn();

    } else {
      // Если команда не прошла фильтр, выводим отладочную информацию
      Serial.print("Игнорирую мусорный код: 0x");
      Serial.println(receivedCode, HEX);
    }
    // Возобновляем прием ИК-сигналов для следующей команды
    IrReceiver.resume();
  }
  // Короткая задержка для стабильности работы системы
  delay(50);
}

// ФУНКЦИЯ ВЫПОЛНЕНИЯ ПОЛНОГО ЦИКЛА НАЖАТИЯ
void pressAndReturn() {
  // ПЕРЕД ДВИЖЕНИЕМ СНОВА ПОДКЛЮЧАЕМ СЕРВОПРИВОД
  myServo.attach(SERVO_PIN);
  // Даем короткую паузу для инициализации управления
  delay(50);
  
  // КОМАНДА НАЖАТИЯ КНОПКИ
  // Устанавливаем угол для нажатия кнопки
  myServo.write(ANGLE_PRESS);
  // Выводим сообщение о действии
  Serial.println("Серва: Нажимаю кнопку...");
  // Ждем, пока серва выполнит движение и удерживает нажатие
  delay(PRESS_DURATION);
  
  // КОМАНДА ВОЗВРАТА В ИСХОДНОЕ ПОЛОЖЕНИЕ
  // Устанавливаем угол исходного положения
  myServo.write(ANGLE_REST);
  // Выводим сообщение о действии
  Serial.println("Серва: Возвращаюсь...");
  // Ждем, пока серва выполнит возвратное движение
  delay(RETURN_DELAY);
  
  // ПОСЛЕ ЗАВЕРШЕНИЯ ЦИКЛА СНОВА ОТКЛЮЧАЕМ УПРАВЛЕНИЕ
  // Это критически важно для предотвращения дрожания!
  myServo.detach();
  
  // Сообщение о готовности к следующей команде
  Serial.println("Цикл завершен. Ожидание новой команды.");
  Serial.println("---");
}